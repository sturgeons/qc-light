# RS485特殊发送协议实现说明

## 📋 协议概述

根据C代码中的`grf_sline_send`函数，命令发送需要遵循特殊协议：

### C代码原始协议

```c
s32 grf_sline_send(u8* header, u32 header_len, u8* data, u32 data_len)
{
    // 步骤1: 设置波特率为230400，发送0x00
    grf_drv_uart_set_cfg(drv_uart, UART_SPEED_230400, ...);
    u8 break_data[1] = {0x00};
    grf_drv_uart_send(drv_uart, break_data, 1);
    
    // 步骤2: 切换波特率为500000，使用偶校验
    grf_drv_uart_set_cfg(drv_uart, UART_SPEED_500000, UART_BIT_8, UART_PARITY_EVEN, UART_STOP_1);
    
    // 步骤3: 发送header字段
    if(header && header_len > 0) {
        grf_drv_uart_send(drv_uart, header, header_len);
    }
    
    grf_delay(1);  // 延迟1ms
    
    // 步骤5: 发送data数组
    if(data && data_len > 0) {
        grf_drv_uart_send(drv_uart, data, data_len);
    }
    
    return GRF_OK;
}
```

### 协议步骤详解

1. **Break信号**: 230400波特率发送0x00
2. **波特率切换**: 切换到500000，8位数据，偶校验，1位停止位
3. **发送Header**: 前4个字节
4. **延迟**: 1ms
5. **发送Data**: 剩余数据字节

## 🔧 Android实现

### 实现位置

**SerialPortManager.java**
```java
public boolean sendToRS485WithProtocol(byte[] header, byte[] data) {
    // 步骤1: 发送break信号 0x00
    byte[] breakSignal = {0x00};
    rs485Port.send(breakSignal);
    
    Thread.sleep(1);
    
    // 步骤2: 发送header
    if (header != null && header.length > 0) {
        rs485Port.send(header);
    }
    
    // 步骤3: 延迟1ms
    Thread.sleep(1);
    
    // 步骤4: 发送data
    if (data != null && data.length > 0) {
        rs485Port.send(data);
    }
    
    return true;
}
```

**CommandSendActivity.java**
```java
// 数据分割
byte[] header = new byte[4];  // 前4字节
System.arraycopy(fullCmd, 0, header, 0, 4);

byte[] data = new byte[dataLen];  // 第6字节开始（跳过0xFC）
System.arraycopy(fullCmd, 5, data, 0, dataLen);

// 使用协议发送
serialPortManager.sendToRS485WithProtocol(header, data);
```

## ⚠️ 实现限制和简化

### 1. 波特率动态切换

**C代码做法**：
```c
// 先230400发送0x00
grf_drv_uart_set_cfg(drv_uart, UART_SPEED_230400, ...);
grf_drv_uart_send(drv_uart, break_data, 1);

// 再切换到500000发送数据
grf_drv_uart_set_cfg(drv_uart, UART_SPEED_500000, ...);
```

**Android限制**：
- Android下改变串口参数需要关闭并重新打开串口
- 频繁开关会影响性能和稳定性
- 当前实现：**直接使用500000波特率发送所有数据**

**建议**：
✅ 在主界面打开RS485时，直接设置波特率为**500000**

### 2. 奇偶校验

**C代码做法**：
```c
// 使用偶校验
grf_drv_uart_set_cfg(drv_uart, UART_SPEED_500000, UART_BIT_8, UART_PARITY_EVEN, UART_STOP_1);
```

**Android限制**：
- 当前SerialPort.cpp中的nativeOpen函数已支持parity参数
- 但主界面打开串口时默认使用无校验（NONE）
- 要修改为偶校验需要修改SerialPort.cpp或SerialPortHelper.java

**解决方案**：
如需使用偶校验，需要修改打开串口的代码：
```java
// SerialPortHelper.java
mFd = nativeOpen(device, baudRate, 8, 1, 2); // 最后参数：0=NONE, 1=ODD, 2=EVEN
```

### 3. 数据分割

✅ **已完整实现**

- Header: 前4字节 (0x55, 命令字节, 地址字节, 校验字节)
- 0xFC: 作为分隔标记，不实际发送
- Data: 从第6字节开始的所有数据

例如ADDR1命令：
```
原始数据: 55 42 61 CE FC FF FF FF FF FF FF FF FF FF FF FF FF FF 0F 22
Header:   55 42 61 CE
分隔符:   FC (不发送)
Data:     FF FF FF FF FF FF FF FF FF FF FF FF FF 0F 22
```

### 4. 延迟时间

✅ **已实现**

```java
Thread.sleep(1);  // 1ms延迟
```

## 📊 完整发送流程对比

### C代码流程
```
1. 设置230400波特率
2. 发送 0x00
3. 设置500000波特率，偶校验
4. 发送 Header (4字节)
5. 延迟 1ms
6. 发送 Data (N字节)
```

### Android实现流程
```
1. (假设已用500000波特率打开RS485)
2. 发送 0x00
3. 延迟 1ms
4. 发送 Header (4字节)
5. 延迟 1ms
6. 发送 Data (N字节)
```

### 主要差异
| 项目 | C代码 | Android实现 | 影响 |
|------|-------|-------------|------|
| 波特率切换 | 动态切换 | 固定500000 | 需预先设置 |
| Break波特率 | 230400 | 500000 | 可能影响设备识别 |
| 奇偶校验 | 偶校验 | 默认无校验 | 需要修改代码 |
| 数据分割 | ✓ | ✓ | 完全一致 |
| 延迟时间 | ✓ | ✓ | 完全一致 |

## 🎯 推荐配置

### 最佳实践

1. **RS485波特率设置**
   ```
   建议：500000
   备选：230400, 115200（测试用）
   ```

2. **如需完整协议支持**，修改SerialPortHelper.java:
   ```java
   // 使用偶校验
   mFd = nativeOpen(device, baudRate, 8, 1, 2); // 2=EVEN parity
   ```

3. **测试顺序**
   - 先用500000波特率测试
   - 如果不工作，尝试230400或115200
   - 检查设备文档确认实际需要的波特率

## 🔍 调试建议

### 发送日志格式
```
[14:30:25.123] 发送 ADDR1-左转 (成功)
Header: 55 42 61 CE | Data: FF FF FF FF FF FF FF FF FF FF FF FF FF 0F 22
```

### 验证要点
1. ✅ Header是否为4字节
2. ✅ Data是否从第6字节开始（跳过0xFC）
3. ✅ 总字节数是否正确
4. ✅ 发送顺序：0x00 → Header → Data

### 如果通信失败
1. 检查波特率设置（建议500000）
2. 验证设备是否需要偶校验
3. 使用示波器或逻辑分析仪检查实际发送的数据
4. 确认设备地址是否正确

## 📝 未来改进方向

如需完全匹配C代码协议，可以考虑：

1. **动态波特率切换**
   - 在发送前临时切换到230400发送0x00
   - 再切换到500000发送实际数据
   - 需要重新实现串口打开逻辑

2. **奇偶校验支持**
   - 在打开RS485时使用偶校验参数
   - 修改SerialPortHelper.java的open方法

3. **更精确的延迟控制**
   - 使用System.nanoTime()实现更精确的延迟

## ✅ 当前实现总结

**已实现功能**：
- ✅ 数据分割（Header + Data）
- ✅ 发送顺序（Break → Header → Delay → Data）
- ✅ 延迟控制（1ms）
- ✅ 日志显示（分Header和Data）

**简化处理**：
- ⚠️ 使用固定波特率500000（不动态切换）
- ⚠️ Break信号使用500000波特率发送（而非230400）
- ⚠️ 默认无奇偶校验（可修改为偶校验）

**建议**：
在大多数情况下，当前实现已足够。如设备通信失败，再考虑完整实现协议细节。

---

**最后更新**: 2025-01-03

