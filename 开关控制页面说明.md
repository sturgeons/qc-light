# 开关控制页面使用说明

## 📋 功能概述

开关控制页面是一个分组开关控制界面，用于**持续发送**特定组的命令。点击开关按钮开启后，该组命令会循环发送，直到再次点击停止。

与命令发送页面的区别：
- **命令发送页面**：批量发送固定次数（如100次、1000次）
- **开关控制页面**：持续循环发送，直到手动停止

## 🔘 分组定义

页面共有6个开关按钮，每个按钮控制一组地址：

| 开关按钮 | 包含地址 | 说明 |
|---------|---------|------|
| **ADDR1-3** | ADDR1, ADDR2, ADDR3 | 左转1-3 |
| **ADDR4-6** | ADDR4, ADDR5, ADDR6 | 左转4-5 + 右转6 |
| **ADDR7-9** | ADDR7, ADDR8, ADDR9 | 右转7-9 |
| **ADDR10-12** | ADDR10, ADDR11, ADDR12 | 右转10-12 |
| **ADDR13-15** | ADDR13, ADDR14, ADDR15 | 左尾13-15 |
| **ADDR16-18** | ADDR16, ADDR17, ADDR18 | 左尾16-18 |

## 🚀 使用方法

### 1. 前提条件

⚠️ **必须先在主界面打开RS485串口**，否则无法发送命令！

### 2. 打开页面

在主界面点击 **"打开开关控制页面"** 按钮（橙色按钮）

### 3. 开启持续发送

- 点击任意分组按钮（如 "ADDR1-3"）
- 按钮变为**绿色**，显示 "运行中"
- 该组命令开始循环发送（每条命令间隔1ms）
- 日志区显示开启信息

**示例日志**：
```
[10:30:15] ADDR1-3 开启
```

### 4. 停止发送

- 再次点击同一个按钮
- 按钮变回**灰色**，显示 "关闭"
- 停止发送该组命令
- 日志区显示停止信息和统计数据

**示例日志**：
```
[10:30:45] ADDR1-3 停止 (共发送30000次, 耗时30.5s)
```

### 5. 多个开关同时运行

- 可以同时开启多个开关
- 每个开关独立控制一组命令
- 互不影响，并发发送

**示例**：可以同时开启 ADDR1-3 和 ADDR7-9，两组命令会同时循环发送

### 6. 停止所有发送

- 点击左上角 **"返回"** 按钮
- 所有正在运行的开关会自动停止
- 返回主界面

## 🔄 发送协议

每条命令都遵循完整的RS485发送协议：

```
1. 切换到363636波特率（无校验）
2. 发送0x00 break信号
3. 延迟1ms
4. 切换到500000波特率（偶校验）
5. 发送Header（前4字节）
6. 等待从机回复0xFC（超时100ms）
7. 延迟1ms
8. 发送Data部分
```

## 📊 日志说明

日志显示关键事件和统计信息（简化模式，减少资源消耗）：

### 日志内容

1. **开启消息**：显示哪个分组开启
2. **停止消息**：显示哪个分组停止 + 发送次数 + 总耗时

### 日志限制

- 自动保留最近30条记录
- 可手动点击 **"清空日志"** 清除所有日志

### 日志示例

```
[10:30:15] ADDR1-3 开启
[10:30:20] ADDR7-9 开启
[10:30:45] ADDR1-3 停止 (共发送30000次, 耗时30.5s)
[10:31:10] ADDR7-9 停止 (共发送50000次, 耗时50.2s)
```

## 🎨 界面说明

### 按钮状态

- **灰色** (#607D8B)：关闭状态
- **绿色** (#4CAF50)：运行中状态

### 按钮文字

- **关闭状态**：`ADDR1-3\n关闭`
- **运行状态**：`ADDR1-3\n运行中`

## ⚡ 性能优化

### 资源消耗控制

1. **日志优化**：只记录开启/停止事件，不记录每条命令
2. **日志限制**：自动保留最近30条
3. **线程管理**：每个开关独立线程，互不阻塞
4. **发送间隔**：1ms间隔，平衡速度和系统负载
5. **并发安全**：使用synchronized保护串口访问，避免多开关同时运行时的数据混乱

### 发送速度

以ADDR1-3为例（3条命令/轮）：
- 每条命令发送时间：约10-20ms（包括协议切换、等待0xFC等）
- 每轮时间：约30-60ms
- 每秒发送：约16-33轮，即48-99条命令
- 运行30秒：约1500-3000条命令

## 📈 使用场景

### 1. 持续测试
长时间持续发送，测试设备的稳定性和可靠性

### 2. 压力测试
同时开启多个开关，进行高强度压力测试

### 3. 功能测试
独立测试每组地址的响应情况

### 4. 耐久测试
长时间运行（如运行数小时），测试设备耐久性

## 🎯 最佳实践

### 1. 测试前准备
- 确认RS485串口已在主界面打开
- 确认状态显示为"已连接"（绿色）
- 确认设备连接正常

### 2. 单组测试
- 先测试单个开关，确认功能正常
- 观察主界面RS485接收区的设备响应
- 确认协议工作正常

### 3. 多组测试
- 确认单组测试成功后，再开启多个开关
- 注意观察系统资源占用
- 避免同时开启所有开关（建议最多3-4个）

### 4. 长时间测试
- 定期检查日志，确认发送正常
- 注意设备温度和状态
- 建议每次测试时间不超过1小时

### 5. 结束测试
- 手动点击按钮停止，查看统计数据
- 或直接返回主界面（自动停止所有）
- 在主界面查看设备的最终响应

## ⚠️ 注意事项

### 1. 串口状态
- **必须先打开RS485串口**
- 如果串口未打开，会弹出提示：`❌ RS485未打开！请先返回主界面打开RS485串口`

### 2. 资源占用
- 长时间运行会持续占用CPU和串口资源
- 建议根据测试需求合理控制运行时间
- 不需要时及时停止

### 3. 并发数量
- ✅ **已修复并发问题**：使用synchronized同步机制，确保多开关同时运行时数据不会混乱
- 理论上可以同时开启6个开关
- 实际建议同时开启不超过3-4个以获得最佳性能
- 多开关同时运行时，发送会自动排队，确保协议正确执行

### 4. 设备响应
- 开启开关后，切换到主界面观察RS485接收区
- 如果设备无响应，检查硬件连接和波特率设置
- 如果设备回复异常，可能是发送速度过快，考虑修改代码增加间隔

### 5. 退出处理
- 点击返回按钮时，所有运行中的开关会自动停止
- 确保资源正确释放，不会产生内存泄漏
- Activity销毁时会调用 `onDestroy()`，停止所有线程

## 🔧 高级功能

### 修改发送间隔

如果需要修改发送间隔时间，可以在 `SwitchControlActivity.java` 中修改：

```java
// 找到这一行（约第255行）
Thread.sleep(1); // 每条命令间隔1ms

// 修改为需要的间隔，例如：
Thread.sleep(10); // 每条命令间隔10ms
```

### 添加新的分组

1. 在 `GROUPS` 数组中添加新的分组定义
2. 在布局文件 `activity_switch_control.xml` 中添加新按钮
3. 在 `initViews()` 中添加按钮ID

## 📝 技术实现

### 核心功能

1. **开关状态管理**：使用 `HashMap<Integer, Boolean>` 管理每个开关的状态
2. **线程管理**：每个开关对应一个独立的发送线程
3. **线程同步**：通过状态标志控制线程的启动和停止
4. **安全退出**：在 `onDestroy()` 中确保所有线程正确停止
5. **并发控制**：使用synchronized关键字保护串口发送方法，避免竞态条件

### 轮流发送机制（队列模式）

**需求**：多个开关同时运行时，应该**轮流交替**发送数据，而不是一个开关发完再发另一个。

**实现方案**：使用发送队列管理器 `SendQueueManager`

#### 架构设计

```
开关1线程 ──┐
            ├─→ [发送队列] ─→ 单一发送线程 ─→ RS485串口 ─→ 从机
开关2线程 ──┤    (FIFO)      (synchronized)
            │
开关3线程 ──┘
```

#### 工作流程

1. **各开关线程**：负责生成命令，将命令添加到队列
2. **发送队列**：FIFO（先进先出）队列，保存待发送的命令
3. **单一发送线程**：从队列取命令并执行完整发送协议
4. **synchronized保护**：确保发送协议的原子性

#### 代码实现

**SendQueueManager.java** - 队列管理器
```java
public class SendQueueManager {
    private BlockingQueue<SendCommand> sendQueue;
    
    public void addCommand(int groupId, byte[] header, byte[] data) {
        SendCommand cmd = new SendCommand(groupId, header, data);
        sendQueue.offer(cmd);  // 添加到队列
    }
    
    // 单一发送线程循环处理
    while (isRunning) {
        SendCommand cmd = sendQueue.take();  // 取出命令
        serialPortManager.sendToRS485WithProtocol(cmd.header, cmd.data);
    }
}
```

**SwitchControlActivity.java** - 开关控制
```java
// 各开关线程只负责添加命令到队列
while (groupStates.get(groupIndex)) {
    for (int i = group.startIndex; i <= group.endIndex; i++) {
        sendQueueManager.addCommand(groupIndex, header, data);
        Thread.sleep(1);
    }
}
```

#### 轮流发送示例

**场景**：开关1(ADDR1-3)和开关2(ADDR7-9)同时运行

```
时间线：
开关1添加: [ADDR1] [ADDR2] [ADDR3] [ADDR1] [ADDR2] ...
开关2添加:       [ADDR7] [ADDR8] [ADDR9] [ADDR7] ...

队列中顺序: [ADDR1] [ADDR7] [ADDR2] [ADDR8] [ADDR3] [ADDR9] [ADDR1] [ADDR7] ...
             ↓      ↓      ↓      ↓      ↓      ↓      ↓      ↓
实际发送顺序: ADDR1  ADDR7  ADDR2  ADDR8  ADDR3  ADDR9  ADDR1  ADDR7 ...
              (1)    (2)    (1)    (2)    (1)    (2)    (1)    (2)
```

**效果**：
- ✅ 多个开关**轮流交替**发送，真正实现公平调度
- ✅ 每个开关发送一条命令后，立即切换到下一个开关
- ✅ 发送协议完整性得到保证（synchronized）
- ✅ 从机能够正确接收和响应所有开关的命令

### 代码结构

```
SendQueueManager (新增)
├── 发送队列 (BlockingQueue)
├── 发送线程 (单一线程处理队列)
├── 启动/停止 (start, stop)
└── 添加命令 (addCommand)

SwitchControlActivity
├── 命令数据 (CMD_LIST)
├── 分组定义 (GROUPS)
├── 状态管理 (groupStates, groupThreads, groupButtons)
├── 队列管理 (sendQueueManager) ← 新增
├── UI初始化 (initViews)
├── 串口初始化 (initSerialPort)
├── 开关控制 (toggleGroup, startGroup, stopGroup)
├── 添加到队列 (addCommandToQueue) ← 修改
└── 日志管理 (updateLog)
```

## 🔗 相关页面

- **主界面**：串口打开/关闭，数据接收显示
- **命令发送页面**：批量发送固定次数的命令
- **开关控制页面**（本页面）：持续循环发送命令

---

**版本**: v1.0  
**创建日期**: 2025-01-03  
**作者**: AI Assistant

